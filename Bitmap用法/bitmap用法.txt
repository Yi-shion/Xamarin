Bitmap用法总结

1、Drawable → Bitmap

public static Bitmap drawableToBitmap(Drawable drawable) {

Bitmap bitmap = Bitmap

.createBitmap(

drawable.getIntrinsicWidth(),

drawable.getIntrinsicHeight(),

drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888

: Bitmap.Config.RGB_565);

Canvas canvas = new Canvas(bitmap);

// canvas.setBitmap(bitmap);

drawable.setBounds(0, 0, drawable.getIntrinsicWidth(),

drawable.getIntrinsicHeight());

drawable.draw(canvas);

return bitmap;

}



2、从资源中获取Bitmap

Resources res=getResources();

Bitmap bmp=BitmapFactory.decodeResource(res, R.drawable.pic);



3、Bitmap → byte[]

private byte[] Bitmap2Bytes(Bitmap bm){

ByteArrayOutputStream baos = new ByteArrayOutputStream();

bm.compress(Bitmap.CompressFormat.PNG, 100, baos);

return baos.toByteArray();

}



4、byte[] → Bitmap

private Bitmap Bytes2Bimap(byte[] b){

if(b.length!=0){

return BitmapFactory.decodeByteArray(b, 0, b.length);

}

else {

return null;

}

}



5、保存bitmap

static boolean saveBitmap2file(Bitmap bmp,String filename){

CompressFormat format= Bitmap.CompressFormat.JPEG;

int quality = 100;

OutputStream stream = null;

try {

stream = new FileOutputStream("/sdcard/" + filename);

} catch (FileNotFoundException e) {

// TODO Auto-generated catch block

e.printStackTrace();

}

return bmp.compress(format, quality, stream);

}



6、将图片按自己的要求缩放

// 图片源

Bitmap bm = BitmapFactory.decodeStream(getResources()

.openRawResource(R.drawable.dog));

// 获得图片的宽高

int width = bm.getWidth();

int height = bm.getHeight();

// 设置想要的大小

int newWidth = 320;

int newHeight = 480;

// 计算缩放比例

float scaleWidth = ((float) newWidth) / width;

float scaleHeight = ((float) newHeight) / height;

// 取得想要缩放的matrix参数

Matrix matrix = new Matrix();

matrix.postScale(scaleWidth, scaleHeight);

// 得到新的图片

Bitmap newbm = Bitmap.createBitmap(bm, 0, 0, width, height, matrix,

true);

// 放在画布上

canvas.drawBitmap(newbm, 0, 0, paint);



7、bitmap的用法小结

BitmapFactory.Options option = new BitmapFactory.Options();

option.inSampleSize = 2; //将图片设为原来宽高的1/2，防止内存溢出

Bitmap bm = BitmapFactory.decodeFile("",option);//文件流

URL url = new URL("");

InputStream is = url.openStream();

Bitmap bm = BitmapFactory.decodeStream(is);



 

//放大缩小图片

public static Bitmap zoomBitmap(Bitmap bitmap,int w,int h){

int width = bitmap.getWidth();

int height = bitmap.getHeight();

Matrix matrix = new Matrix();

float scaleWidht = ((float)w / width);

float scaleHeight = ((float)h / height);

matrix.postScale(scaleWidht, scaleHeight);

Bitmap newbmp = Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix,

true);

return newbmp;

}



//将Drawable转化为Bitmap

public static Bitmap drawableToBitmap(Drawable drawable){

int width = drawable.getIntrinsicWidth();

int height = drawable.getIntrinsicHeight();

Bitmap bitmap = Bitmap.createBitmap(width, height,

drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888

: Bitmap.Config.RGB_565);

Canvas canvas = new Canvas(bitmap);

drawable.setBounds(0,0,width,height);

drawable.draw(canvas);

return bitmap;

}





//获得圆角图片的方法

public static Bitmap getRoundedCornerBitmap(Bitmap bitmap,float roundPx){

Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap

.getHeight(), Config.ARGB_8888);

Canvas canvas = new Canvas(output);

final int color = 0xff424242;

final Paint paint = new Paint();

final Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());

final RectF rectF = new RectF(rect);

paint.setAntiAlias(true);

canvas.drawARGB(0, 0, 0, 0);

paint.setColor(color);

canvas.drawRoundRect(rectF, roundPx, roundPx, paint);

paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));

canvas.drawBitmap(bitmap, rect, rect, paint);

return output;

}





//获得带倒影的图片方法

public static Bitmap createReflectionImageWithOrigin(Bitmap bitmap){

final int reflectionGap = 4;

int width = bitmap.getWidth();

int height = bitmap.getHeight();

Matrix matrix = new Matrix();

matrix.preScale(1, -1);

Bitmap reflectionImage = Bitmap.createBitmap(bitmap,

0, height/2, width, height/2, matrix, false);

Bitmap bitmapWithReflection = Bitmap.createBitmap(width, (height + height/2),

Config.ARGB_8888);

Canvas canvas = new Canvas(bitmapWithReflection);

canvas.drawBitmap(bitmap, 0, 0, null);

Paint deafalutPaint = new Paint();

Generated by Foxit PDF Creator ? Foxit Software

http://www.foxitsoftware.com For evaluation only.

canvas.drawRect(0, height,width,height + reflectionGap,

deafalutPaint);

canvas.drawBitmap(reflectionImage, 0, height + reflectionGap, null);

Paint paint = new Paint();

LinearGradient shader = new LinearGradient(0,

bitmap.getHeight(), 0, bitmapWithReflection.getHeight()

+ reflectionGap, 0x70ffffff, 0x00ffffff, TileMode.CLAMP);

paint.setShader(shader);

// Set the Transfer mode to be porter duff and destination in

paint.setXfermode(new PorterDuffXfermode(Mode.DST_IN));

// Draw a rectangle using the paint with our linear gradient

canvas.drawRect(0, height, width, bitmapWithReflection.getHeight()

+ reflectionGap, paint);

return bitmapWithReflection;

}

}